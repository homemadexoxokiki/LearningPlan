 
hrun -v
v4.3.5
 
Echo 命令
•	> 会创建新文件或覆盖已有文件。
•	>> 会向已有文件末尾追加内容。
•	echo. 用于添加一个空行。
•	行首的空格（缩进） 对YAML文件至关重要，必须保留。

写一个新文件
notepad testcases\demo_testcase.yml

按 Ctrl+S 保存，关闭记事本。


config:
  name: "demo testcase"
  base_url: "https://httpbin.org"

teststeps:
- name: get request
  request:
    method: GET
    url: /get
  validate:
  - eq: [status_code, 200]
  - eq: ["body.url", "https://httpbin.org/get"]
或

config:
  name: "demo testcase"
  base_url: "https://httpbin.org"

teststeps:
- name: get request
  request:
    method: GET
    url: /get
  validate:
  - eq: [status_code, 200]
  - eq: ["body.url", "https://httpbin.org/get"]

hrun startproject test_project
cd ai_resilience_test
hrun testcases/demo_testcase.yml

快速验证网络连通性
# 方法1：用Python测试
python -c "import urllib.request; print('网络正常' if urllib.request.urlopen('http://httpbin.org/get').status == 200 else '网络异常')"

# 方法2：用curl（如果有安装）
curl -I http://httpbin.org/get

修改内容
del testcases\demo_testcase.yml
notepad testcases\demo_testcase.yml

失败：E   check_value: 0(int)
status_code: 0 意味着：DNS解析失败、网络完全不通、或防火墙阻止

解决方法：
查询我的代理服务器:端口 http://proxyhk.huawei.com:8080
set http_proxy=http://http://proxyhk.huawei.com:8080
set https_proxy=http://http://proxyhk.huawei.com:8080
set no_proxy=localhost,127.0.0.1
///DAY2
https://httprunner.com/docs/

# 清除所有代理设置
set http_proxy=
set https_proxy=
set HTTP_PROXY=
set HTTPS_PROXY=
set no_proxy=

#验证网路是否连通
python -c "import socket; socket.gethostbyname('www.baidu.com')"

#创建测试用例（testcases/offline_test.yml）
config:
  name: "离线模拟测试"
  variables:
    mock_data: {"status": "success", "code": 200}

teststeps:
- name: "模拟API响应"
  request:
    method: GET
    url: "about:blank"  # 特殊URL，不真正发起网络请求
  extract:
    response_code: 200
    response_body: "$mock_data"
  validate:
  - eq: [status_code, 200]
  - eq: ["$response_body.status", "success"]

#建立本地文件-创建自定义函数（debugtalk.py）来模拟请求
python -c "content = '''import time\n\ndef mock_request(url, method=\"GET\", **kwargs):\n    \"\"\"模拟HTTP请求，完全不依赖网络\"\"\"\n    print(f\"模拟请求: {method} {url}\")\n    \n    # 模拟响应\n    class MockResponse:\n        def __init__(self):\n            self.status_code = 200\n            self.headers = {\"Content-Type\": \"application/json\"}\n            self.text = '{\"status\": \"success\", \"code\": 200, \"url\": \"' + url + '\"}'\n            self.elapsed = type('Elapsed', (), {'total_seconds': lambda: 0.1})()\n    \n    return MockResponse()\n'''; open('debugtalk.py', 'w', encoding='utf-8').write(content); print('文件创建成功')"

//
import time

def mock_request(url, method="GET", **kwargs):
    """模拟HTTP请求，完全不依赖网络"""
    print(f"模拟请求: {method} {url}")
    
    # 模拟响应
    class MockResponse:
        def __init__(self):
            self.status_code = 200
            self.headers = {"Content-Type": "application/json"}
            self.text = '{"status": "success", "code": 200, "url": "' + url + '"}'
            self.elapsed = type('Elapsed', (), {'total_seconds': lambda: 0.1})()
    
    return MockResponse()

#验证文件是否正确
type debugtalk.py
显示文件内容

#创建使用模拟函数的测试用例（testcases/mock_test.yml）
python -c "import os;os.makedirs('testcase',exist_ok=True)
//
config:
  name: "使用模拟函数的测试"
  variables:
    test_url: "https://api.example.com/test"

teststeps:
- name: "模拟API调用"
  request:
    method: GET
    url: "$test_url"
  setup_hook:
    - ${mock_request($test_url, "GET")}
  validate:
  - eq: ["status_code", 200]
  - eq: ["$mock_data.status", "success"]


【两种CMD写Python的方式】
①直接在 write() 函数里写入字符串内容（换行、双引号需要加转义）
python -c "import os; 
# 创建目录
os.makedirs('testcases', exist_ok=True);
#写入文件
open('testcases\\use_mock_test.yaml', 'w', encoding='utf-8').write('内容')"
② 先赋值再写入：先用变量存储内容，再写入文件
python -c 
# 定义内容
"content = '''内容'''; open('testcases\\use_mock_test.yaml', 'w', encoding='utf-8').write(content)"


#批量创建文件
①

②

python
import os
# 确保testcases目录存在
os.makedirs("testcases", exist_ok=True)
cases = {
    "basic_get.yml": """
   脚本1
""",
    
   脚本2
""",
    
   脚本3
"""
}

for filename, content in cases.items():
    with open(f"testcases/{filename}", "w", encoding="utf-8") as f:
        f.write(content)
    print(f"已创建: {filename}")

print("Day 2 所有用例已生成！")

for filename, content in cases.items():
    filepath = os.path.join("testcases", filename)
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(content)
    print(f"✓ 已创建: {filepath}")

print("\n✅ Day 2 所有用例已生成！")
print("运行测试: hrun testcases/")

【Day1 Summary】
1、YAML结构：config、teststeps、variables
2、理解变量使用：全局变量、局部变量、变量引用
3、掌握断言写法：eq、contains等验证器
  
2、变量
config:
  variables:
    global_var: "全局变量"  # 全局变量，所有teststeps可用

teststeps:
  - name: "步骤1"
    variables:
      local_var: "局部变量"  # 局部变量，只在当前步骤可用
    request:
      url: "/get"
      method: GET
      params:
        global: "$global_var"     # ✓ 可以访问
        local: "$local_var"       # ✓ 可以访问
        
  - name: "步骤2"
    request:
      url: "/get"
      method: GET
      params:
        global: "$global_var"     # ✓ 可以访问
        local: "$local_var"       # ✗ 报错！局部变量不可访问

提取变量	step.extract	后续steps	$变量名	从响应中提取，后续step可用
参数化变量	config.parameters	参数化循环	$变量名	数据驱动测试时使用

3、断言

验证器	作用	示例
eq	相等	eq: ["status_code", 200]
contains	包含	contains: ["body.text", "success"]
startswith	以...开头	startswith: ["body.url", "http"]
endswith	以...结尾	endswith: ["body.filename", ".json"]
length_eq	长度等于	length_eq: ["body.items", 3]
type_match	类型匹配	type_match: ["body.id", "int"]
regex_match	正则匹配	regex_match: ["body.email", ".*@.*\\.com"]

注意：列表项用 - 开头（- name / - eq）

